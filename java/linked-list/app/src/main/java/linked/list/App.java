/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package linked.list;

public class LinkedList {
  // Head and tail pointers for the linked list
  Node head = null;
  Node tail = null;

  // Inserts a new node with the given value at the end of the list
  public void insert(int value) {
    Node newNode = new Node(value);
    if (head == null) {
      head = newNode;
      tail = newNode;
    } else {
      tail.next = newNode;
      tail = newNode;
    }
  }

  // Appends a new node with the given value at the end of the list (same as insert)
  public void append(int value) {
    // Code is the same as insert method
    insert(value);
  }

  // Inserts a new node with newValue immediately before the first node with the value
  public void insertBefore(int value, int newValue) {
    Node newNode = new Node(newValue);
    if (head == null) {
      return;
    }

    if (head.value == value) {
      newNode.next = head;
      head = newNode;
      return;
    }

    Node currentNode = head;
    while (currentNode.next != null && currentNode.next.value != value) {
      currentNode = currentNode.next;
    }

    if (currentNode.next != null) {
      newNode.next = currentNode.next;
      currentNode.next = newNode;
    }
  }

  // Inserts a new node with newValue immediately after the first node with the value
  public void insertAfter(int value, int newValue) {
    Node newNode = new Node(newValue);
    Node currentNode = head;

    while (currentNode != null && currentNode.value != value) {
      currentNode = currentNode.next;
    }

    if (currentNode != null) {
      newNode.next = currentNode.next;
      currentNode.next = newNode;
    }
  }

  // Returns true if the list contains a node with the given value, false otherwise
  public boolean includes(int value) {
    Node currentNode = head;
    while (currentNode != null) {
      if (currentNode.value == value) {
        return true;
      }
      currentNode = currentNode.next;
    }
    return false;
  }

  // Returns a string representation of the linked list
  @Override
  public String toString() {
    StringBuilder result = new StringBuilder();
    Node currentNode = head;
    while (currentNode != null) {
      result.append("{ ").append(currentNode.value).append(" } -> ");
      currentNode = currentNode.next;
    }
    result.append("NULL");
    return result.toString();
  }

  // Returns the value of the node k positions from the end of the list
  public int kthFromEnd(int k) {
    if (k < 0) {
      throw new IllegalArgumentException("k must be a non-negative integer.");
    }

    Node firstPointer = head;
    Node secondPointer = head;

    for (int i = 0; i <= k; i++) {
      if (firstPointer == null) {
        throw new IllegalArgumentException("k is greater than the length of the linked list.");
      }
      firstPointer = firstPointer.next;
    }

    while (firstPointer != null) {
      firstPointer = firstPointer.next;
      secondPointer = secondPointer.next;
    }

    return secondPointer.value;
  }
  public static LinkedList zipLists(LinkedList list1, LinkedList list2) {
    // This function takes two linked lists and returns a new linked list that is the concatenation of the two lists.

    // If either list is empty, return the other list.
    if (list1.head == null) {
      return list2;
    }

    if (list2.head == null) {
      return list1;
    }

    // Create a new linked list to store the zipped lists.
    LinkedList zippedList = new LinkedList();

    // Create two pointers to the current nodes in the two lists.
    Node list1Current = list1.head;
    Node list2Current = list2.head;

    // While both lists have nodes, append the value of the current node in each list to the new list.
    while (list1Current != null || list2Current != null) {
      if (list1Current != null) {
        zippedList.append(list1Current.value);
        list1Current = list1Current.next;
      }

      if (list2Current != null) {
        zippedList.append(list2Current.value);
        list2Current = list2Current.next;
      }
    }

    // Return the new list.
    return zippedList;
  }


  // Nested Node class representing the elements in the linked list
  public static class Node {
    public int value;
    public Node next = null;

    Node(int value) {
      this.value = value;
    }
  }
}
